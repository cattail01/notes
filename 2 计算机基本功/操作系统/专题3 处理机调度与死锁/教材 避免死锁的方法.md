### 避免死锁的方法

#### 系统的安全状态

* 按某种顺序，并发进程都获得最大资源顺序完成的序列为安全序列。能找到安全序列的状态为安全状态。

#### 安全状态之例

| **进程** | **最大需求** | **已分配** | **可用** |
| -------- | ------------ | ---------- | -------- |
| **P1**   | **10**       | **5**      | **3**    |
| **P2**   | **4**        | **2**      |          |
| **P3**   | **9**        | **2**      |          |

* 安全序列：p2 p1 p3

#### 安全——不安全的转换

上例中，若P3再申请一台，则此时系统是否安全？

| **进程** | **最大需求** | **已分配** | **可用** |
| -------- | ------------ | ---------- | -------- |
| **P1**   | **10**       | **5**      | **2**    |
| **P2**   | **4**        | **2**      | ** **    |
| **P3**   | **9**        | **3**      | ** **    |

### 利用银行家算法避免死锁

#### 银行家算法中的数据结构：

* n：系统中进程总数；m：资源类别总数
* **Available**[1..m]表示每类**资源的剩余数量**
* **Allocation**[1..n,1..m]表示**当前给每个进程分配的各种资源数量**
* **Need**[1..n,1..m]表示当前**每个进程还需分配的各种资源数**
* **Max[i,j]**= Allocation[i,j] + Need[i,j]
* Requesti[1..m]表示进程**Pi提出的资源申请**

#### 银行家算法

* 针对进程Pi提出资源申请Request i [ j ]=k
  * 若Request i [ j ]≤Need [i, j],继续;否则错误返回
  * 若Request i [ j ]≤Available [ j ],继续;否则进程等待
* 系统试图分配资源：
  * Available [ j ]=Available [ j ]-Requesti [ j ];
  * Allocation [i ,j]=Allocation [i, j] +Requesti [ j ];
  * Need[i,j]=Need[ I, j]-Requesti [ j ]；
* 用安全算法对该状态进行安全检测，若不安全则试探分配作废。

