[toc]

### 9.2.5 赋值和swap

#### 所有容器对象支持的赋值运算

| 操作                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| c1=c2                             | 将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的容器类型，且保存的是相同的元素类型 |
| c={a, b, c, ...}                  | 将c1中的元素替换为初始化列表中元素的拷贝（array不适用）。保存的必须是相同的元素类型 |
| swap(c1, c2)                      | 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 |
| c1.swap(c2)                       | 同上                                                         |
| assign操作不适用于关联容器和array |                                                              |
| seq.assign(b, e)                  | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素。保存的元素类型必须相容。 |
| seq.assign(items)                 | 将seq中的元素替换为初始化列表items中的元素                   |
| seq.assign(n, t)                  | 将seq中的元素替换为n个值为t的元素                            |

##### 注意

* 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。
* swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）。

#### 使用assign（仅顺序容器）

* 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。

* 原理：参数指定的元素的拷贝赋值，替换左边容器的所有元素

#### 使用swap

##### 使用swap

* 交换两个相同容器中的内容

##### swap原理

* 交换两个容器内容的操作保证会很快----元素本身并未交换，swap只是交换了两个容器的内部数据结构（相当于交换了一下引用）

##### 内部指针、引用的变化规律

* 元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作都不会失效。他们仍然指向操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。

* 对一个string调用swap会导致迭代器、引用和指针失效。

* swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

  因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。

#### 非成员函数版本的swap（C++11）

* 尽量使用非成员函数版本的swap
* 泛型编程中十分重要

