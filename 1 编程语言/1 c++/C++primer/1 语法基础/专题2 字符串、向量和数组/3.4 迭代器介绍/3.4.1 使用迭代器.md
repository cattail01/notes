### 3.4.1 使用迭代

**获得迭代器的方法**  
> 有迭代器的类型同时拥有返回迭代器的成员  
    例如可能存在的`begin`和`end`的成员
    
* `begin`：指向容器中的第一个元素
* `end`：指向容器中最后一个元素的下一个位置，叫法：*尾后迭代器*
* 容器为空，则v.begin() == v.end()
* 现在不清楚返回类型，所以定义时用`auto`类型关键字

**迭代器运算符**  
【表3.6】标准容器迭代器的运算符

运算符 | 作用
---|---
*iter | 返回迭代器所指元素的引用
iter->mem | 解引用并获取成员
++iter | 向下移动元素
--iter | 向上移动元素
iter1 == iter2, iter1 != iter2 | 判断指向是否为同一个元素

* 结论：与指针极像，估计就是一个东西

【示例】获取和使用迭代器

```C++
auto it = s.begin();
*it = toupper(*it);
```

**迭代器的移动**  
* 类似于指针的移动  

【示例】第一个单词改成大写形式(迭代器)

```C++
for(auto it = s.begin(); it != s.end() &&  !isspeace(*it); it ++)
    *it = toupper(*it);
```

**迭代器衍生的C++判断方法：泛型编程**  
> C++程序员更喜欢使用!=而非<

* 迭代器类型是不确定类型，绝大多数情况不支持<，但是支持!=
* 只要养成使用!=的习惯，就不用在意用的迭代器到底是哪种类型

**迭代器类型**  
* 大多数情况下，迭代器标准库类型使用`iterator`和`const_iterator`
* 其中，不带const的可以读写，带const只能读取
* 如果容器是一个常量，则只能用带const的内个

**begin和end运算符返回类型**  
* 如果对象是常量，则返回const_iterator；反之，则返回iterator
* 如果想要返回的是const_iterator，可以使用C++11::cbegin()和cend()

**结合解引用和成员访问操作**  
* 使用情况：在指针或迭代器所指向的对象是类（typedef和class）时
* 使用方法：`(*it).empty()` `it->empty()`
* 错误使用：`*it->empty()` 运算符优先级

**某些对vector对象的操作会使迭代器失效**  
* 谨记：使用迭代器作为循环条件，不能向迭代器指向的容器添加元素

